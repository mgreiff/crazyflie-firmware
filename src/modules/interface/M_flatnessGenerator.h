/******************************************************************************
 * This script may look very strange and computationally heavy, but most of the
 * are simple re-declarations and multiplications. The most intense aspect is
 * the 3x3 matreix inversion (occurring at two places) roughtly half
 * of the script can be disabled if we only want the body rates and not
 * feed forward torque terms. The equations are derived for the Z-Y-X
 * euler angle (or tait byrian) representation, and therefore differ slightly
 * from the equations used by Mellinger [1]. The mathematics and derivations
 * can be provided at request.
 *
 * The basic idea is to take the flat outputs generated by the sequence
 * commander and fill a structure containing the states
 * (i)    Translational positions (global frame)                            [m]
 * (ii)   Translational velocities (global frame)                         [m/s]
 * (iii)  Translational accelerations (global frame)                    [m/s^2]
 * (iv)   SO(3) rotation parametrized by a matrix (global to body frame)
 * (v)    SO(3) rotation parametrized by Euler angles                     [rad]
 * (vi)   SO(3) rotation parametrized by quaternions in Hamilton form
 * (vii)  Euler angle rates                                             [rad/s]
 * (viii) Body rates                                                    [rad/s]
 * (ix)   Body Accelerations                                          [rad/s^2]
 * (x)    Thrust                                                            [N]
 * (xi)   Torques                                                          [Nm]
 *
 * uniquely determined by the trajectory in the flat outputs.
 *
 * ~~~ Changelog ~~~
 * Editor        | Date       | Description
 *-----------------------------------------------------------------------------
 * Marcus Greiff | 28-11-2016 | Initial commit (not yet validated against
 *                            | Matlab/Simulink simulation)
 *****************************************************************************/
 
// Avoid redefinitions
#ifndef __M_FLATNESSGENERATOR_H__
#define __M_FLATNESSGENERATOR_H__

#define MASS 0.027
#define GRAVACC 9.81

#include <stdbool.h>
#include <stdint.h>

#include "M_types.h"

// Expands states by means of differential flatness
void flatnessExpansion_M(M_setpoint_t *SetPoint, M_mode_t *mode);

// Cross product for computing body frames
void crossProduct(float u[], float v[], float res[]);

// Dot product of two vectors
float dotProduct(float u[], float v[]);

// Vecor normalization
void normalize(float u[], float res[]);

// Two norm computation
float twoNorm(float u[]);

// Sign function
float signFunction(float u);
#endif //__M_FLATNESSGENERATOR_H__
